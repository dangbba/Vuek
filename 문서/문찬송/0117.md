# 220117

### 공통 PJT 관련 진행한 내용

```
2주 동안 Java / Spring을 학습해본 바, 기본적인 언어 문법에 대한 이해 + 프레임워크에 대한 이해가 부족하고 습득이 더뎌(노력과 의지가 부족한 탓도 있겠으나, 슬프지만 1학기때도 원래 습득이 느린 편이었습니다..😥)  남은 PJT 기간 동안 간단한 기능이라도 개발이 가능할 정도로 수준을 올리기는 어렵다는 판단과 조금이라도 할 수 있는 업무로 팀에 기여하고 싶다는 생각에 팀장님과 팀원분들께 양해를 구해 기존에 배웠던 Vue.js를 사용하는 프론트엔드로 업무를 변경하게 되었습니다. 모두의 배려를 받은 만큼 팀에 기여할 수 있도록 어렵지만 포기하지 않고 끝까지 노력하겠습니다.
```



### Vue.js 기본 구조 복습 등

##### 																								 (팀 기존 문서 & 1학기 WS 자료 참조)

#### 1. Vue 프로젝트 파일 구조

- node_modules : node.js 환경의 여러 의존성 모듈
  - public/index.html : vue앱의 뼈대가 되는 파일, 실제 제공되는 단일 html 파일
  - src
    - assets : webpack에 의해 빌드 된 정적 파일
    - views : 하위 컴포넌트들이 위치하는 곳
    - common : element-plus와 기본 css, 그리고 관련 js파일들의 집합

#### 2. 프로젝트 생성

```bash
1. Vue 설치
$ npm install -g @vue/cli 

2. 버전 확인
$ vue --version 
@vue/cli 4.5.15

3. 프로젝트 생성
$ vue create <프로젝트명>

4. 프로젝트 디렉토리 이동
$ cd <프로젝트명>

5. 서버 실행
$ npm run serve
```

#### 3. Vue Router 관련

```bash
프로젝트 생성 및 이동
$ vue create <프로젝트명>
$ cd <프로젝트명>
```

- src / router / index.js

```vue
import Vue from 'vue'
import VueRouter from 'vue-router'
import TodoList from '@/views/todos/TodoList'
import CreateTodo from '@/views/todos/CreateTodo'
import Signup from '@/views/accounts/Signup'
import Login from '@/views/accounts/Login'

Vue.use(VueRouter)

const routes = [
  {
    path: '/todos',
    name: 'TodoList',
    component: TodoList,
  },
  {
    path: '/todos/create',
    name: 'CreateTodo',
    component: CreateTodo,
  },
  {
    path: '/accounts/signup',
    name: 'Signup',
    component: Signup,
  },
  {
    path: '/accounts/login',
    name: 'Login',
    component: Login,
  },
]

const router = new VueRouter({
  mode: 'history',
  base: process.env.BASE_URL,
  routes
})

export default router

```

- src / accounts / App.vue

```vue
<template>
  <div id="app">
    <div id="nav">
      <span v-if="isLogin"> <!--isLogin이 true이면(로그인중이면) 렌더링-->
        <router-link :to="{ name: 'TodoList' }">Todo List</router-link> | 
        <router-link :to="{ name: 'CreateTodo' }">Create Todo</router-link> |
        <!-- 로그아웃 버튼 아니라 라우터 링크로 만든 것임 -->
        <router-link @click.native="logout" to="#">Logout</router-link> <!-- a태그의 모양을 가지고 있지만 a태그 고유(click) 이벤트가 없는 router-link 태그이기 대문에, .native 수식어를 사용해 click 이벤트를 실행할 수 있도록 함-->
                                              <!-- to 프로퍼티값이 없으면 렌더링이 되지 않기 때문에 "#"으로 작성-->
                                              <!-- router-link는 히스토리를 쌓으면서 이동시켜주는 역할.. -->
      </span>
      <span v-else> <!--isLogin이 false이면(로그인중이 아니면) 렌더링-->
        <router-link :to="{ name: 'Signup' }">Signup</router-link> |
        <router-link :to="{ name: 'Login' }">Login</router-link> 
      </span>
    </div>
      <!-- router-link를 통해 전달받은 내용을 router-view에 출력 -->
      <!-- 라우터를 쓰게 되면 컴포넌트의 위치가 이렇게 됨... -->
    <router-view @login="changeLogin"/> <!-- 하위컴포넌트에서 받은 이벤트로 메서드 호출 / 메서드를 만드는 것이 좀 더 명확한 방식 -->
    <!-- <router-view @login="isLogin=true"/> -->     <!-- 코드를 바로 작성 :  메서드 호출하는 대신에 명령문을 바로 사용하는 방식을 취한 것임
                                    디렉티브 안에 쓰일 때는 this가 필요가 없다 login 이벤트를 청취하면 isLogin 데이터를 true로 변경-->
    
  </div>
</template>

<script>
export default {
  name: 'App',
  data: function () {
    return {
      isLogin: false, // 기본값: 비로그인시 false
    }
  },
  created: function () { // 페이지 생성시 jwt토큰 여부에 따라 isLogin 데이터 값을 토글 
    // 1) Vue Instance가 생성된 직후에 호출되어 jwt를 가져오기
    const token = localStorage.getItem('jwt')
    // 2) 토큰이 있으면
    if (token) {
      // 3) true로 변경하고 없으면 유지
      this.isLogin = true
    }
  },
  methods: {
    // logout은 따로 component가 필요하지는 않음
    changeLogin: function () {
      this.isLogin = true
    },
    logout: function () {
      this.isLogin = false // 로그아웃시 component의 isLogin 데이터를 false로 변경해야함
      localStorage.removeItem('jwt') // 로컬스토리지에 저장된 토큰을 삭제
      this.$router.push({ name: 'Login '}) // 로그아웃 이후에는 Login 컴포넌트를 렌더링
    }
  },
}
</script>

<style>
#app {
  font-family: Avenir, Helvetica, Arial, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  text-align: center;
  color: #2c3e50;
}

#nav {
  padding: 30px;
}

#nav a {
  font-weight: bold;
  color: #2c3e50;
}

#nav a.router-link-exact-active {
  color: #42b983;
}
</style>

```

#### 4. 회원가입, 로그인 관련

- src / views / Signup.vue

```bash
<template>
  <div>
    <h1>회원가입</h1>
    <div>
      <label for="username">사용자 이름: </label>
      <input 
        type="text"
        id="username"
        v-model="credentials.username"
      > <!-- data와 양방향 바인딩 -->
    </div>

    <div>
      <label for="password">비밀번호: </label>
      <input 
        type="password"
        id="password"
        v-model="credentials.password"
      > <!-- input type을 password로 지정하면 입력창에 *로 표시된다! -->
    </div>
  
    <div>
      <label for="passwordConfirmation">비밀번호 확인: </label>
      <input 
        type="password"
        id="passwordConfirmation"
        v-model="credentials.passwordConfirmation"
        @keyup.enter="signup"
      >
    </div>
  
    <button @click="signup">회원가입</button>

  </div>
</template>

<script>
import axios from 'axios'

// const SERVER_URL = process.env.VUE_APP_SERVER_URL

export default {
  name: 'Singup',
  data: function () {
    return {
      // 회원가입을 위해 필요한 정보
      credentials: { // form 데이터와 양방향 바인딩된 정보
        username: null,
        password: null,
        passwordConfirmation: null,
      }
    }
  },
  methods: {
    signup: function () {
      //console.log(this.credentials)
      axios({ // 아래와 같은 정보를 담아서 axios요청 ('post'요청)을 보낸다
        method: 'post',
        url: 'http://127.0.0.1:8000/accounts/signup/',
        data: this.credentials
      })
        // 요청이 성공했으면

        // 로그인 컴포넌트로 이동하기
        // .then(()=> {
        //   // console.log(res) // 요청이 성공했을때 들어온 정보를 보기
        //   this.$router.push({ name: 'Login' }) // 로그인 컴포넌트로 이동 // name은 index.js에 작성된 routes 정보의 name
        // })

        // 회원 가입 후 자동 로그인 설정
        // 회원 가입 요청에 성공했다면
        .then(()=> {
          // 로그인 요청
          axios({
            method: 'post',
            url: 'http://127.0.0.1:8000/accounts/api-token-auth/',
            data: this.credentials, // 인스턴스 내에 있는 것! this 빠지면 오류난다
          })
            .then(res => {
              localStorage.setItem('jwt', res.data.token)
              this.$emit('login')
              this.$router.push({ name: 'TodoList' })
            })
            .catch(err => {
              console.log(err)
            })
        })
        //요청에 실패하면
        .catch(err => {
          console.log(err)
        })       
    }
  },
}
</script>
```

- src / views / Login.vue

```vue
<template>
  <div>
    <h1>로그인</h1>
    <div>
      <label for="username">사용자 이름: </label>
      <input 
        type="text"
        id="username"
        v-model="credentials.username"
      > <!-- data와 양방향 바인딩 -->
    </div>

    <div>
      <label for="password">비밀번호: </label>
      <input 
        type="password"
        id="password"
        v-model="credentials.password"
        @keyup.enter="login"
      > <!-- input type을 password로 지정하면 입력창에 *로 표시된다! -->
      <!--엔터 이벤트시 로그인 메소드 호출-->
    </div>
  
    <button @click="login">로그인</button> <!--클릭 이벤트시 로그인 메소드 호출-->
  </div>
</template>

<script>
import axios from 'axios'

// const SERVER_URL = process.env.VUE_APP_SERVER_URL

export default {
  name: 'Login',
  data: function () {
    return {
      credentials: {
        username: null,
        password: null,
      }
    }
  },
  methods: {
    login: function () {
      axios({
        method: 'post',
        url: 'http://127.0.0.1:8000/accounts/api-token-auth/', // 로그인 요청 이후 Server는 JWT를 발급 후 응답
        data: this.credentials, // 해당 데이터를 전송 
      })
        // 요청 성공시
        .then(res => {
          // console.log(res) // login페이지에서 로그인 시도 후 콘솔에서 응답 데이터 확인
          localStorage.setItem('jwt', res.data.token) // 로컬스토리지에 저장
          // console.log(localStorage.getItem('jwt')) // 'jwt'데이터 확인
          
          // App 컴포넌트는 login data가 변경된 사실을 알 수 없기 때문에 emit login 이벤트 호출하여 부모 컴포넌트에게 알림
          this.$emit('login') //TodoList 컴포넌트로 push 하기 이전에 이벤트를 통해 로그인이 되었다는 사실을 부모 컴포넌트에게 알리고,
                            // App컴포넌트 이벤트가 발생하면 그 때 isLogin 데이터의 값을 true로 변경해야함
          this.$router.push({ name: 'TodoList' }) // 로그인 이후에는 TodoList 경로로 이동
        })
        .catch(err => {
          console.log(err)
        })
    }
  }
}
</script>

```

#### 4. Vuex 관련

- Vuex를 활용한 todo 프로젝트 코드

- src / store / index.js

```vue
import Vue from 'vue'
import Vuex from 'vuex'

import createPersistedState from 'vuex-persistedstate' // 로컬 저장소

Vue.use(Vuex)

export default new Vuex.Store({
  plugins: [
    createPersistedState(),
  ],
  state: {
    todos: [
      // {
      //   title: '할일1',
      //   isCompleted: false,
      //   date: new Date().getTime() // Date()-> 오브젝트 / getTime() -> 정수값으로 변환==> 유일값을 갖도록 하는 요소
      // }, // 테스트용 객체
      // {
      //   title: '할일2',
      //   isCompleted: false,
      //   date: new Date().getTime()
      // }, // 테스트용 객체
    ] // 배열
  }, // 상태 단위로 공통적으로 관리해야하는 데이터
  mutations: { // state를 변경하는 함수
    // 데이터가 생성되어서 늘어난 상태
    CREATE_TODO: function (state, todoItem) { // 파라미터 정해져있다 todoItem은 payload
      state.todos.push(todoItem)
    },
    // 데이터가 삭제되어서 줄어든 상태
    DELETE_TODO: function (state, todoItem) {
      const index = state.todos.indexOf(todoItem)
      state.todos.splice(index, 1) // splice 사용법: 어디서부터 몇 개 지워줘 // idx부터 1개
    },
    UPDATE_TODO: function (state, todoItem) {
      state.todos = state.todos.map(todo => {
        if (todo === todoItem) {
          return {
            ...todoItem,
            isCompleted: !todoItem.isCompleted // 값을 바꿈 true->false / false->true
          }
            // const newItem = {
          //   title: todo.title,
          //   isComleted: !todo.iscompleted,
          //   date: todo.date
          // }
          // return newItem
        } else {
          // 일치하지 않으면 기존 배열 return
          return todo
        }
      }) // map의 사용법상 함수를 만들라고 되어있다..! > 하나씩의 데이터를 가져다가....
    }
  },  // 비동기 함수 절대로 쓰면 안된다 // 순서가 바뀔 수 있기 때문에 안된다
  actions: {
    createTodo: function ({commit}, todoItem) { // context와 todoItem
                        // (context, todoItem)
      //console.log(context) //context 안에 엄청나게 많은 것들이 들어있다-commit, state, dispatch 등등등 : 
                          // 여러가지가 있는데 필요한 것만 구조분해할당 형식으로 불러올 수도 있다
      // context.commit('CREATE_TODO', todoItem)
      commit('CREATE_TODO', todoItem)
    },
    deleteTodo: function ({commit}, todoItem) {
      commit('DELETE_TODO', todoItem)
    },
    updateTodo: function ({commit}, todoItem) {
      commit('UPDATE_TODO', todoItem)
    }
  }, // 비동기 관련된 함수들 사용해도 된다 // 컴포넌트가 원래 하던 일이기 때문에 괜찮다
  getters: {
    completedTodosCount: function (state) {
      return state.todos.filter(todo => {
        return todo.isCompleted // isCompleted === true
      }).length
    },
    unCompletedTodosCount: function (state) {
      return state.todos.filter(todo => {
        return !todo.isCompleted // isCompleted === false
      }).length
    },
    allTodosCount: function (state) {
      return state.todos.length
    }
  } // 사용할 수도 있고 안할 수도 있어서 기본값은 아니다
  // modules: {
  // } // 기본 setting이지만 우리 프로젝트에서는 사용하지 않음
})
```

- src / App.vue

```vue
<template>
  <div id="app"> <!-- 이거 지우면 큰일난다!! -->
    <h1>Todo List</h1>
    <h2>All Todos: {{ allTodosCount }}</h2>
    <h2>Completed Todo: {{ completedTodosCount }}</h2> <!--{{ $store.getters.completedTodosCount }} : 밑에 computed에 정의-->
    <h2>Uncompleted Todo: {{ unCompletedTodosCount }}</h2> 
    <todo-list></todo-list>
    <todo-form></todo-form>
  </div>
</template>
<script>
import TodoForm from './components/TodoForm.vue'
import TodoList from './components/TodoList.vue'
import { mapGetters } from 'vuex'

export default {
  name: 'App',
  components: {
    TodoForm,
    TodoList,
  },
  computed: {
    ...mapGetters([
      'completedTodosCount',
      'unCompletedTodosCount',
      'allTodosCount' // 문자열 정의
    ])
    // completedTodosCount: function () {
    //   return this.$store.getters.completedTodosCount
    // },
    // unCompletedTodosCount: function () {
    //   return this.$store.getters.unCompletedTodosCount
    // },
    // allTodosCount: function () {
    //   return this.$store.getters.allTodosCount
    // }
  }
}
</script>

<style>
#app {
  font-family: Avenir, Helvetica, Arial, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  text-align: center;
  color: #2c3e50;
  margin-top: 60px;
}
</style>

```

- src / components /

  - TodoForm.vue

    ```vue
    <template>
      <div>
        <input type="text"
        v-model="todoTitle"
        @keyup.enter="createTodo"
        >
         <!-- 입출력 양방향 가능하도록 하는 v-model-->
         <!-- @ === v-on의 축약어 -->
         <!-- 이벤트가 발생했을때 동작하도록 하는 함수이름 createTodo-->
        <button @click="createTodo">add</button>
      </div>
    </template>
    
    <script>
    export default {
      name: 'TodoForm',
      data: function () {
        return {
          todoTitle: null
        } 
      },
      methods: {
        createTodo: function () {
          const todoItem = {
            title: this.todoTitle, // this
            isCompleted: false, // 초기값
            data: new Date().getTime() // getTime()을 사용해야 정수값으로 변환이 된다
          } // 객체생성
          if (this.todoTitle) {
            this.$store.dispatch('createTodo', todoItem) //actions를 호출 // todo객체를 보내줘야한다
            this.todoTitle = null // 인풋박스에 들어온 todoTitle을 빈값으로 다시 돌려준다
          } // 인스턴스의 todoTitle이 빈 값 아닐 때만 action 취하자
        }
      }
    }
    </script>
    
    <style>
    
    </style>
    
    ```

  - TodoList.vue

    ```vue
    <template>
      <div>
        <todo-list-item 
        v-for="todo in todos"
        :key="todo.date"
        :todo="todo"
        > <!-- 태그 안에다가 디렉티브를 넣어줌 -->
          <!-- todo 안에 있는거 하나를 가져다가 key로 사용(유일한 date 정수값) -->
          <!-- todos === $store.state.todos (아래에서 computed로 정의..) -->
          <!-- 상위에서 하위로 데이터 전달할 때는 props로 전달 -->
        </todo-list-item>
      </div>
    </template>
    
    <script>
    import TodoListItem from './TodoListItem' // 상대경로
                            // '@/components/TodoListItem'으로 작성도 가능 "src === @"로 축약해서 사용 :절대경로
    import { mapState } from 'vuex'
    
    export default {
      name: 'TodoList', // 따옴표가 안 붙은 경우--메모리를 가지고 있고... // object 안에 있는 것은 일종의 딕셔너리처럼 사용
                       // component명은 class처럼 들어가는 것이라서 Pascal case 사용 권장 
      components: { 
        TodoListItem 
      },
      computed: {
        ...mapState([
          'todos',
        ])
    // todos: function () {
        //   // .......
        //   return this.$store.state.todos // this:나의 인스턴스에 대한.... // this 빼면 안된다 // 어떤 인스턴스에 대한 것인지 명확하게 붙여서 써줘야 한다
        // }
      } // 미리 가져다 놓기! 먼저 들어오는 데이터에 대해 미리 계산을 해가지고 미리 cache에 넣어놀거야
    }
    </script>
    
    <style>
    
    </style>
    
    ```

  - TodoListItem.vue

    ```vue
    <template>
      <div> 
        <span 
          @click="updateTodo"
          :class="{ completed: todo.isCompleted }"
        > <!-- 디렉티브의 v-바인드의 옵션을 사용 -->
          {{ todo.title }}
          </span>
        <button @click="deleteTodo">delete</button>
          <!-- click 이벤트에 따른 method 호출 -->
      </div>
    </template>
    
    <script>
    export default {
      name: 'TodoListItem',
      props: {
        todo: Object, // props로 상위에서 하위로 받아온 데이터 // props 할때는 객체의 타입을 작성
      },
      methods: {
        deleteTodo: function() {
          this.$store.dispatch('deleteTodo', this.todo) // 현재 todo오브젝트를 삭제하는 actions를 호출하는 method를 작성 // 페이로드:this.todo
        },
        updateTodo: function() {
          this.$store.dispatch('updateTodo', this.todo) // 현재 todo오브젝트를 삭제하는 actions를 호출하는 method를 작성 // 페이로드:this.todo
        }
      }
    }
    </script>
    
    <style>
      .completed {
        text-decoration: line-through; /*줄이 그어진다*/
      }
    </style>
    ```

    

----

### Git branch 관련

##### Git 원격 브랜치 가져오기

1. remote 원격 레포지토리 보기

   - 로컬 repository에 모든 branch가 없을 수 있다. 

   - 다음 명령어를 통해 원격 repository의 브랜치 목록을 볼 수 있다..!

     ```bash
     git branch -r
     ```

2. 원격 레포지토리 브랜치 소스 보기

   - 원격 브랜치의 소스를 보기만 하고 싶을 때는 임시로 원격브랜치로 checkout

   - checkout은 다른 브랜치로 스위치하는 명령어

   - 예시

     ```bash
     git checkout origin/develop
     	  		 (원격브랜치명)
     ```

3. 원격 레포지토리의 브랜치를 로컬브랜치에 checkout하기

   - 원격 브랜치를 로컬 브랜치로 가져오기

   - 예시

     ```bash
     git checkout -t origin/develop
     	    		 (원격브랜치명)
     ```

   - 기존에는 local에서 remote와 같은 이름의 브랜치를 만들어서 switch한 후 pull 받아 commit한 내용들이 중첩되고 꼬이는 현상들이 발생했었는데.. 오늘 이은택코치님의 jira/git 발표 세션 웹엑스 참여를 통해 원격브랜치를 로컬 브랜치로 가져오는 방법이 있다는 것을 알게 되었다..!
     - git checkout -t develop으로 해서 안되길래 찾아보니 origin/develop 형식으로 입력해야 한다는 것을 알게 되었다.

4. 원격 브랜치 이름을 로컬에서는 바꾸어서 checkout하는 명령어

   ```
   git checkout -b my_develop origin/develop
   		   (생성할 브랜치 이름) (원격 브랜치 이름)
   ```

---



### 처리해야 할 업무들...

- Vue.js | Vuex 관련 기능 학습
- Page rendering 관련 고민
- 로그인 | 회원가입 | 프로필 관련 기능
  - 기존 코드 및 사용 라이브러리 분석 
  - 기능 적용
    - axios....

